<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WebXR Photo Gallery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- iOS-style fonts & background -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background-color: #f2f2f7;
      color: #1c1c1e;
      overflow: hidden;
    }

    /* HEADER */
    .header {
      background: rgba(255,255,255,0.92);
      position: sticky;
      top: 0;
      padding: 16px 20px;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      z-index: 100;
      backdrop-filter: blur(10px);
    }
    .header h1 {
      margin: 0;
      font-size: 28px;
      font-weight: 700;
      display: inline-block;
    }
    .header button {
      float: right;
      padding: 10px 20px;
      background: rgba(0,122,255,0.9);
      color: #fff;
      border: none;
      border-radius: 20px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .header button:hover {
      background: rgba(0,122,255,1);
    }

    /* GALLERY OVERLAY IN XR */
    .gallery-container {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      max-height: 30%;
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 8px;
      overflow-y: auto;
      display: none;
      z-index: 2002;
    }
    .gallery-container.active {
      display: block;
    }
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 6px;
    }
    .gallery-grid .photo-item {
      position: relative;
      padding-bottom: 100%;
      border-radius: 6px;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      background: #e0e0e0;
    }
    .gallery-grid .photo-item:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .gallery-grid .photo-item img {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* XR CANVAS & UI */
    #xr-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000;
      z-index: 2000;
      display: none;
    }
    #xr-overlay canvas {
      width: 100%;
      height: 100%;
    }
    .exit-ar {
      position: absolute;
      top: 20px; right: 20px;
      background: rgba(255,255,255,0.25);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 48px; height: 48px;
      font-size: 24px;
      cursor: pointer;
      backdrop-filter: blur(5px);
      display: none;
      z-index: 2001;
    }
    #status {
      position: absolute;
      bottom: 50%;
      left: 50%;
      transform: translate(-50%, 50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 12px 20px;
      border-radius: 24px;
      font-size: 16px;
      display: none;
      z-index: 2001;
      max-width: 80%;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- HEADER WITH ENTER-AR BUTTON -->
  <header class="header">
    <h1>Photo Gallery</h1>
    <button id="enter-ar">Enter AR</button>
  </header>

  <!-- MAIN GALLERY (displayed but only clickable once in AR) -->
  <div class="gallery-container" id="gallery-container">
    <div class="gallery-grid" id="photo-grid"></div>
  </div>

  <!-- XR OVERLAY -->
  <div id="xr-overlay">
    <button class="exit-ar" id="exit-ar">×</button>
    <div id="status"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';

    // -- Photo data --
    const photoURLs = [
      './Photo/photo1.jpg',
      './Photo/photo2.jpg',
      './Photo/photo3.jpg',
      './Photo/photo4.jpg',
      './Photo/photo5.jpg',
      // …add more
    ];

    // -- XR state --
    let camera, scene, renderer;
    let controllers = [];
    let xrSession = null;
    let photoFrames = [];
    let activeControllers = new Set();
    let interactionMode = 'none';
    let selectedPhoto = null;
    let initialControllerPositions = {};
    let initialDistance = 0;
    let initialScale = new THREE.Vector3();
    let initialRotation = 0;

    // STATUS UTILS
    function updateStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.display = 'block';
      if (!isError) {
        setTimeout(() => el.style.display = 'none', 4000);
      }
    }

    // -- Build the gallery UI --
    function initPhotoGrid() {
      const grid = document.getElementById('photo-grid');
      photoURLs.forEach(url => {
        const item = document.createElement('div');
        item.className = 'photo-item';
        const img = document.createElement('img');
        img.src = url;
        img.alt = '';
        item.appendChild(img);

        // Click inside XR => add photo
        item.addEventListener('click', () => {
          if (xrSession) {
            addPhotoToAR(url);
          }
        });

        grid.appendChild(item);
      });
    }

    // -- THREE/WebXR setup --
    function initXR() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.getElementById('xr-overlay').appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040, 2));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(1,1,1);
      scene.add(dirLight);

      window.addEventListener('resize', onWindowResize);
    }

    // -- ENTER AR SESSION --
    function startARSession() {
      if (!navigator.xr) {
        updateStatus('WebXR not supported', true);
        return;
      }
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        if (!supported) {
          updateStatus('AR not supported on this device', true);
          return;
        }
        const opts = {
          requiredFeatures: ['hit-test','dom-overlay'],
          optionalFeatures: ['hand-tracking'],
          domOverlay: { root: document.body }
        };
        navigator.xr.requestSession('immersive-ar', opts).then(onSessionStarted);
      });
    }

    function onSessionStarted(session) {
      xrSession = session;
      renderer.xr.setSession(session);
      renderer.xr.setReferenceSpaceType('local');

      // Show XR UI
      document.getElementById('xr-overlay').style.display = 'block';
      document.getElementById('exit-ar').style.display = 'block';
      document.getElementById('enter-ar').style.display = 'none';

      // Reveal gallery inside AR
      document.getElementById('gallery-container').classList.add('active');
      updateStatus('Tap a photo below to place it in AR');

      setupControllers();
      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnded);
    }

    function onSessionEnded() {
      document.getElementById('xr-overlay').style.display = 'none';
      document.getElementById('exit-ar').style.display = 'none';
      document.getElementById('gallery-container').classList.remove('active');
      document.getElementById('enter-ar').style.display = 'inline-block';

      // Clean up
      scene.clear();
      photoFrames = [];
      controllers = [];
      xrSession = null;
      renderer.setAnimationLoop(null);
    }

    // -- Add a photo into the AR scene --
    function addPhotoToAR(url) {
      const loader = new THREE.TextureLoader();
      const width = 0.5;
      const border = 0.02;

      // placeholder frame
      const geo = new THREE.PlaneGeometry(width, width * (3/4));
      const mat = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
      const plane = new THREE.Mesh(geo, mat);

      // white border
      const bgeo = new THREE.PlaneGeometry(width + border, width * (3/4) + border);
      const bmat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
      const borderMesh = new THREE.Mesh(bgeo, bmat);
      borderMesh.position.z = -0.001;

      const group = new THREE.Group();
      group.add(plane, borderMesh);
      group.position.set(0, 0, -0.8);
      scene.add(group);
      photoFrames.push(group);

      loader.load(url, tex => {
        const ar = tex.image.width / tex.image.height;
        const h = width / ar;

        // update geometries
        plane.geometry.dispose();
        plane.geometry = new THREE.PlaneGeometry(width, h);
        borderMesh.geometry.dispose();
        borderMesh.geometry = new THREE.PlaneGeometry(width + border, h + border);

        // apply texture
        plane.material.dispose();
        plane.material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });

        updateStatus('Photo placed! Tap another to add more.');
      }, undefined, err => {
        console.error(err);
        updateStatus('Failed to load photo', true);
      });
    }

    // -- Controllers for move/scale/rotate --
    function setupControllers() {
      for (let i=0; i<2; i++) {
        const ctrl = renderer.xr.getController(i);
        ctrl.userData.id = i;
        scene.add(ctrl);
        ctrl.addEventListener('selectstart', onSelectStart);
        ctrl.addEventListener('selectend', onSelectEnd);
        controllers.push(ctrl);
      }
    }

    function onSelectStart(evt) {
      const ctrl = evt.target;
      const pos = new THREE.Vector3();
      ctrl.getWorldPosition(pos);
      activeControllers.add(ctrl.userData.id);

      if (interactionMode === 'none') {
        const hit = findClosestFrame(pos);
        if (!hit) return;
        selectedPhoto = hit;
        interactionMode = 'move';
        selectedPhoto.userData.offset = new THREE.Vector3().subVectors(hit.position, pos);
        updateStatus('Moving photo');
      }
      else if (interactionMode === 'move' && activeControllers.size === 2) {
        interactionMode = 'transform';
        // store initial
        controllers.forEach(c => {
          const cp = new THREE.Vector3(); c.getWorldPosition(cp);
          initialControllerPositions[c.userData.id] = cp;
        });
        initialDistance = getDistance();
        initialScale.copy(selectedPhoto.scale);
        // rotation
        const l = initialControllerPositions[0], r = initialControllerPositions[1];
        initialRotation = Math.atan2(r.x - l.x, r.z - l.z);
        updateStatus('Rotate/Scale mode');
      }
    }

    function onSelectEnd(evt) {
      const ctrl = evt.target;
      activeControllers.delete(ctrl.userData.id);
      if (interactionMode === 'transform' && activeControllers.size === 1) {
        interactionMode = 'move';
        updateStatus('Back to move mode');
      }
      if (activeControllers.size === 0) {
        interactionMode = 'none';
        selectedPhoto = null;
        updateStatus('Tap photo to interact');
      }
    }

    function findClosestFrame(point) {
      let closest = null, dist = Infinity;
      photoFrames.forEach(f => {
        const d = point.distanceTo(f.position);
        if (d < 0.2 && d < dist) {
          dist = d; closest = f;
        }
      });
      return closest;
    }
    function getDistance() {
      const p0 = new THREE.Vector3(), p1 = new THREE.Vector3();
      controllers[0].getWorldPosition(p0);
      controllers[1].getWorldPosition(p1);
      return p0.distanceTo(p1);
    }

    function handleInteraction() {
      if (!selectedPhoto) return;
      if (interactionMode === 'move' && activeControllers.size === 1) {
        const id = [...activeControllers][0];
        const ctrl = controllers[id], pos = new THREE.Vector3();
        ctrl.getWorldPosition(pos);
        selectedPhoto.position.copy(pos).add(selectedPhoto.userData.offset);
      }
      else if (interactionMode === 'transform' && activeControllers.size === 2) {
        // current controllers
        const cur = {};
        controllers.forEach(c => {
          const p = new THREE.Vector3(); c.getWorldPosition(p);
          cur[c.userData.id] = p;
        });
        // scale
        const dist = getDistance();
        let sf = dist / initialDistance;
        sf = Math.min(3, Math.max(0.5, sf));
        selectedPhoto.scale.copy(initialScale).multiplyScalar(sf);
        // rotate
        const l = cur[0], r = cur[1];
        const angle = Math.atan2(r.x - l.x, r.z - l.z);
        const delta = angle - initialRotation;
        selectedPhoto.rotation.y += delta;
        // reposition at midpoint
        const mid = new THREE.Vector3().addVectors(l, r).multiplyScalar(0.5);
        const forward = new THREE.Vector3(0,0,-0.05).applyQuaternion(camera.quaternion);
        selectedPhoto.position.copy(mid).add(forward);
      }
    }

    function render(time, frame) {
      if (frame) handleInteraction();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // -- ENTRY POINT --
    document.addEventListener('DOMContentLoaded', () => {
      initPhotoGrid();
      initXR();
      document.getElementById('enter-ar').addEventListener('click', startARSession);
      document.getElementById('exit-ar').addEventListener('click', () => xrSession && xrSession.end());
    });
  </script>
</body>
</html>
